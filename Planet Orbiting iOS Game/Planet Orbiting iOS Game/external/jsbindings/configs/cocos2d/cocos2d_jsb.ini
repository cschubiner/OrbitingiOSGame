#########################################################
#
#           cocos2d
#
# Contains cocos2d common classes.
# Classes that contain iOS specific or Mac specific code
# that should be parsed should be moved the the
# iOS or Mac sub-sections
#########################################################
[cocos2d]

# prefix that will be removed from the ObjC classes in order to generate the JS classes
# ex: If the class name is CCNode, then on JavaScript it will be Node
obj_class_prefix_to_remove = CC

# Classes to generate. Use '*' to generate all the parsed classes.
# Subclasses will be parsed as well.
# ex: If CCSprite is parsed, then CCNode and NSObject will be parsed as well
# It supports regular expressions to match class names.
# eg: all cocos2d actions ending in 'By': CC(.*)By
classes_to_parse = CC(.*)

# Classes to ignore.
# It is a good idea to add classes that you don't want to have a proxy object. Usually internal classes,
# or classes that are already native on JavaScript should be added here.
# It supports regular expressions to match class names.
# eg: all NS classes: NS(.*)
#
# cocos2d comments:
# CCMenu, CCLayer* and CCDirector(*) are ignored because they are parsed on the iOS / Mac variants
# CCCallFunc*: Not needed... only CallBlockN is used
classes_to_ignore = NS(.*), CCArray, CCWindow, CCGLView, CCLayer(.*), CCMenu, CCDirector(.*), CCCallFunc(.*), CCCallBlockO,

# Class properties
# Options
#  manual               Means that the class is manually bound. No binding info will generated, but it can be used.
#  name:"newname"       New name of the class
class_properties =  NSObject = manual,
                NSEvent = manual,
                CCCallBlockN = name:"CallFunc"; reserved_slots:2,
                CCParticle(.*) = inherit_class_methods:True,
                CCParticleSystem = name:"_ParticleSystem",
                CCParticleSystemQuad = name:"ParticleSystem",
                CCMenuItem(.*) = reserved_slots:2,
                CCTransition(.*) = inherit_class_methods:True,

# Whether or not to generate constructors from base classes for the current class.
# In JavaScript, the "constructors" or "static methods" are not "inherited".
# It is recommended to set it to "auto".
# Options:
#    False: Don't inherited
#    True: Inherit all class methods from all ancestors
#    Auto: Inherit only if it has no class constructors. Stop when the fist class constructor is added.
inherit_class_methods = Auto

# Files that are going to be imported by the autogenerated files.
# Useful to declare subclasses of an already bound project
# eg: manual bindings for NSObject
import_files = js_bindings_NS_manual.h, js_bindings_cocos2d_manual.h



# The prefix will be removed from function name.
# eg: if the C function is "cpBodyAddShape", then the JS name will be "bodyWithAddShape"
## For cocos2d add "cc"
function_prefix_to_remove = cc

# Free functions to be parsed
functions_to_parse = cc(.*)

# Free functions not to parse
## ccc3, ccc4, ccc4f are created manually in JS since it is faster at runtime.
functions_to_ignore = ccArray*, ccCArray*, ccc3, ccc4, ccc4f,

# Free functions properties
# Options
#  manual               Means that the class is manually bound. No binding info will generated, but it can be used.
#  name:"newname"       New name of the class
## _native_p is used for testing purposes.
function_properties =  ccp = name:"_native_p",

# Rules used for methods:
# options:
#   name:"js_name"         Rename methods.
#   ignore                 This method will be ignored.
#   callback               This method is a callback. It will be invoked from Objective-C
#   no_swizzle             It means that the callback function is an optional protocol and should not be "swizzled" because there is no implementation for it.
#   variadic_2_array       It means that all arguments are variadic, and an Array will be created with them
#   merge:name | name...   List of methods names that should be merged with this method as well.
#   manual                 It means that its implementation won't be autogenerated. It is implemented manually
#
#  Regular expressions are supported in the Class names, but not in the Method names
#
method_properties =  CC(.*) # node = name:"create",
                CC(.*) # texture = name:"getTexture",
                CCNode # addChild:z:tag: = name:"addChild"; merge:"addChild:" | "addChild:z:",
                CC(.*) #removeChild:cleanup: = name:"removeChild",
                CC(.*) # removeChildByTag:cleanup: = name:"removeChildByTag",
                CCNode # reorderChild:z: = name:"reorderChild",
                CCNode # schedule:interval:repeat:delay: = name:"schedule"; merge:"schedule:interval:" | "schedule:"; manual,
                CCNode # boundingBox = name:"getBoundingBox",
                CC(.*) # setBlendFunc: = manual,
                CC(.*) # blendFunc = ignore,
                CCSequence#actionWithArray: = variadic_2_array; name:"create",
                CCSpawn#actionWithArray: = variadic_2_array; name:"create",
                CCRepeat#actionWithAction:times: = name:"create",
                CCRepeatForever#actionWithAction: = name:"create",
                CCRotate(.*)#actionWithDuration:angle: = name:"create",
                CCMove(.*)#actionWithDuration:position: = name:"create",
                CCTint(.*)#actionWithDuration:red:green:blue: = name:"create",
                CCJump(.*)#actionWithDuration:position:height:jumps: = name:"create",
                CCSkew(.*)#actionWithDuration:skewX:skewY: = name:"create",
                CCProgressTo # actionWithDuration:percent: = name:"create",
                CCProgressFromTo # actionWithDuration:from:to: = name:"create",
                CCProgressTimer # progressWithSprite: = name:"create",
                CCFade(.*)#actionWithDuration: = name:"create",
                CCFadeTo # actionWithDuration:opacity: = name:"create",
                CCBlink#actionWithDuration:blinks: = name:"create",
                CCAnimate#actionWithAnimation: = name:"create",
                CCFlipY#actionWithFlipY: = name:"create",
                CCFlipX#actionWithFlipX: = name:"create",
                CCPlace#actionWithPosition: = name:"create",
                CCShow#action = name:"create",
                CCHide#action = name:"create",
                CCToggleVisibility#action = name:"create",
                CCDelayTime#actionWithDuration: = name:"create",
                CCFollow # actionWithTarget:worldBoundary: = name:"create"; merge:"actionWithTarget:",
                CCEase(.*) # actionWithAction: = name:"create",
                CCEaseIn # actionWithAction:rate: = name:"create",
                CCEaseInOut # actionWithAction:rate: = name:"create",
                CCEaseOut # actionWithAction:rate: = name:"create",
                CCEaseElastic(.*) # actionWithAction:period: = name:"create"; merge:"actionWithAction:",
                CCCallBlockN # actionWithBlock: = name: "create"; manual,
                CCTargetedAction # actionWithTarget:action: = name:"create",
                CCActionManager # addAction:target:paused: = name:"addAction",
                CCActionManager # getActionByTag:target: = name:"getActionByTag",
                CCActionManager # removeActionByTag:target: = name:"removeActionByTag",
                CCNode#onEnter = callback,
                CCNode#onEnterTransitionDidFinish = callback,
                CCNode#onExit = callback,
                CCNode#onExitTransitionDidStart = callback,
                CCNode#update: = callback,
                CCLabelAtlas#labelWithString:fntFile: = name:"create",
                CCLabelBMFont#labelWithString:fntFile: = name:"create",
                CCLabelTTF#labelWithString:fontName:fontSize:dimensions:hAlignment: = name:"create"; merge:"labelWithString:fontName:fontSize:",
                CCParticleSystemQuad # particleWithFile: = name:"create",
                CCParticleSystemQuad # particleWithTotalParticles: = name:"createWithTotalParticles",
                CCRenderTexture # renderTextureWithWidth:height:pixelFormat:depthStencilFormat: = name:"create"; merge:"renderTextureWithWidth:height:pixelFormat:" | "renderTextureWithWidth:height:",
                CCRenderTexture # clear:g:b:a: = name:"clear",
                CCRenderTexture # saveToFile:format: = name:"saveToFile"; merge:"saveToFile:",
                CCDrawNode # drawDot:radius:color: = name:"drawDot",
                CCDrawNode # drawSegmentFrom:to:radius:color: = name:"drawSegment",
                CCDrawNode # drawPolyWithVerts:count:fillColor:borderWidth:borderColor: = name:"drawPoly"; manual,
                CCTexture2D#resolutionType = ignore,
                CCTexture2D # setTexParameters: = manual,
                CCScale(.*) # actionWithDuration:scaleX:scaleY: =  name:"create"; merge:"actionWithDuration:scale:",
                CCCatmullRom(.*) # actionWithDuration:points: = name:"create",
                CCCardinalSpline(.*) # actionWithDuration:points:tension: = name:"create",
                CCShaky3D # actionWithRange:shakeZ:grid:duration: = name:"create",
                CCWaves3D # actionWithWaves:amplitude:grid:duration: = name:"create",
                CCFlip(.*)3D # actionWithDuration: = name:"create",
                CC(.*)Sprite # spriteWithFile:rect: = name:"create" ; merge:"spriteWithFile:",
                CC(.*)Sprite # spriteWithTexture:rect: = name:"createWithTexture"; merge:"spriteWithTexture:",
                CC(.*)Sprite # spriteWithSpriteFrame: = name:"createWithSpriteFrame",
                CC(.*)Sprite # spriteWithSpriteFrameName: = name:"createWithSpriteFrameName",
                CC(.*)Sprite # initWithFile:rect: = name:"init" ; merge:"initWithFile:",
                CC(.*)Sprite # initWithTexture:rect: = name:"initWithTexture"; merge:"initWithTexture:",
                CC(.*)Sprite # initWithSpriteFrameName: = name:"initWithSpriteFrameName",
                CCSpriteBatchNode # batchNodeWithFile:capacity: = name:"create"; merge:"batchNodeWithFile:",
                CCSpriteBatchNode # batchNodeWithTexture:capacity: =  name:"createWithTexture"; merge:"batchNodeWithTexture:",
                CCMenuItem # setIsEnabled: = name:"setEnabled",
                CCMenuItem # getIsEnabled: = name:"getEnabled",
                CCMenuItem # setBlock: = name:"setCallback"; manual,
                CCMenuItemImage # itemWithNormalImage:selectedImage:disabledImage:block: = name:"create" ; merge:"itemWithNormalImage:selectedImage:block:"; manual,
                CCMenuItemImage # initWithNormalImage:selectedImage:disabledImage:block: = name:"init" ; merge:"initWithNormalImage:selectedImage:block:"; manual,
                CCMenuItemSprite # itemWithNormalSprite:selectedSprite:disabledSprite:block: = name:"create" ; merge:"itemWithNormalSprite:selectedSprite:block:"; manual,
                CCMenuItemSprite # initWithNormalSprite:selectedSprite:disabledSprite:block: = name:"init" ; merge:"initWithNormalSprite:selectedSprite:block:"; manual,
                CCMenuItemFont # itemWithString:block: = name:"create" ; merge:"itemWithString:"; manual,
                CCMenuItemFont # initWithString:block: = name:"init" ; merge:"initWithString:"; manual,
                CCMenuItemLabel # itemWithLabel:block: = name:"create" ; merge:"itemWithLabel:"; manual,
                CCMenuItemLabel # initWithLabel:block: = name:"init" ; merge:"initWithLabel:"; manual,
                CCMenuItemToggle # itemWithItems: = name:"create" ; variadic_2_array,
                CCMenuItemToggle # initWithItems: = name:"init" ; variadic_2_array,
                CCParallaxNode # addChild:z:parallaxRatio:positionOffset: = name:"addChild",
                CCTMXTiledMap # tiledMapWithTMXFile: = name:"create",
                CCTMXLayer # setTileGID:at: = name:"setTileGID",
                CCTileMapAtlas # tileMapAtlasWithTileFile:mapFile:tileWidth:tileHeight: = name:"create",
                CCTransition(.*) # transitionWithDuration:scene: = name:"create",
                CCTransitionFade # transitionWithDuration:scene:withColor: = name:"create"; merge:"transitionWithDuration:scene:",
                CCTransitionPageTurn # transitionWithDuration:scene:backwards: = name:"create"; merge:"transitionWithDuration:scene:",
                CCSpriteFrameCache # sharedSpriteFrameCache = name:"getInstance",
                CCSpriteFrameCache # addSpriteFramesWithFile:textureFilename: = name:"addSpriteFrames"; merge:"addSpriteFramesWithFile:",
                CCSpriteFrameCache # spriteFrameByName: = name:"getSpriteFrame",
                CCAnimation # animationWithAnimationFrames:delayPerUnit:loops: =  name:"create"; merge: "animation" | "animationWithSpriteFrames:" | "animationWithSpriteFrames:delay:",
                CCAnimationCache # sharedAnimationCache = name:"getInstance",
                CCAnimationCache # animationByName: = name:"getAnimation",
                CCAnimationCache # removeAnimationByName: = name:"removeAnimation",
                CCAnimationCache # addAnimation:name: = name:"addAnimation",
                CCAnimationCache # addAnimationsWithFile: = name:"addAnimations",
                CCPhysicsDebugNode # debugNodeForCPSpace: = name:"create",
                CCPointArray # arrayWithCapacity: = name:"create",
                CCTextureCache # sharedTextureCache = name:"getInstance",
                CCSpriteFrame # frameWithTexture:rectInPixels:rotated:offset:originalSize: = name:"createWithTexture"; merge:"frameWithTexture:rect:",
                CCSpriteFrame # frameWithTextureFilename:rectInPixels:rotated:offset:originalSize: = name:"create"; merge:"frameWithTextureFilename:rect:",
                CCFileUtils # macFileExistsAtPath: = ignore,
                CCFileUtils # macRetinaDisplayFileExistsAtPath: = ignore,
                CCFileUtils # macRetinaDisplaySuffix = ignore,
                CCFileUtils # macSuffix = ignore,
                CCFileUtils # setMacRetinaDisplaySuffix: = ignore,
                CCFileUtils # setMacSuffix: = ignore,
                CCGLProgram # setUniformForModelViewProjectionMatrix = ignore,

#
# Struct properties
# options:
#   opaque              The structure will be treated as 'opaque' and can't not be inspected from JS.
#                       Opaque structures are much faster to generate than 'manual' or 'automatic' structures
#   manual:[func]       Manual conversion is provided for this structures. jsval_to_structname() and structname_to_jsval shall exists in your project
#                       If "func" is passed, it will call that conversion function
struct_properties = CGPoint = manual,
                    CGSize = manual,
                    CGRect = manual,
                    ccColor3B = manual,
                    ccColor4B = manual,
                    ccColor4F = manual,
                    ccGridSize = manual,
                    cpBody = opaque,
                    cpSpace = opaque,

# BridgeSupport files
# add as many as you need. Usually you will only one.
bridge_support_file = cocos2d.bridgesupport

# File that contains information that complements BridgeSupport (not present on BridgeSupport file)
complement_file = cocos2d-complement.txt

#########################################################
#
#           cocos2d Mac
#
# Contains information for classes with specific Mac
# information like CCLayer (its subclasses should also
# be added here)
#########################################################
[cocos2d_mac]

# prefix that will be removed from the ObjC classes in order to generate the JS classes
# ex: If the class name is CCNode, then on JavaScript it will be Node
obj_class_prefix_to_remove = CC

# Classes to generate. Use '*' to generate all the parsed classes.
# Subclasses will be parsed as well.
# ex: If CCSprite is parsed, then CCNode and NSObject will be parsed as well
# It supports regular expressions to match class names.
# eg: all cocos2d actions ending in 'By': CC(.*)By
classes_to_parse = CCNode, CCLayer(.*), CCMenu, CCDirector(.*),

# Classes to ignore.
# It is a good idea to add classes that you don't want to have a proxy object. Usually internal classes,
# or classes that are already native on JavaScript should be added here.
# It supports regular expressions to match class names.
# eg: all NS classes: NS(.*)
classes_to_ignore = NS(.*), CCArray, CCWindow, CCGLView,

# Class properties
# Options
#  manual               Means that the class is manually bound. No binding info will generated, but it can be used.
#  name:"newname"       New name of the class
class_properties =  NSObject = manual,
                NSEvent = manual,
                CCScene = manual,
                CCScheduler = manual,
                CCActionManager = manual,
                CCNode = manual,

# Whether or not to generate constructors from base classes for the current class.
# In JavaScript, the "constructors" or "static methods" are not "inherited".
# It is recommended to set it to "auto".
# Options:
#    False: Don't inherited
#    True: Inherit all class methods from all ancestors
#    Auto: Inherit only if it has no class constructors. Stop when the fist class constructor is added.
inherit_class_methods = Auto

# Files that are going to be imported by the autogenerated files.
# Useful to declare subclasses of an already bound project
# eg: manual bindings for NSObject
import_files =  js_bindings_cocos2d_classes.h

# The prefix will be removed from function name.
# eg: if the C function is "cpBodyAddShape", then the JS name will be "bodyWithAddShape"
## For cocos2d add "cc"
function_prefix_to_remove =

# Free functions to be parsed
functions_to_parse =

# Free functions not to parse
functions_to_ignore =

# Rules used for methods:
# options:
#   name:"js_name"         Rename methods.
#   ignore                 This method will be ignored.
#   callback               This method is a callback. It will be invoked from Objective-C
#   no_swizzle             It means that the callback function is an optional protocol and should not be "swizzled" because there is no implementation for it.
#   variadic_2_array       It means that all arguments are variadic, and an Array will be created with them
#
#  Regular expressions are supported in the Class name, but not in the Method name
#
method_properties =  CC(.*) # node = name:"create",
                CCDirector # sharedDirector = name:"getInstance",
                CCDirector # winSize = name:"getWinSize",
                CCMenu # menuWithArray: = variadic_2_array; name:"create",
                CCMenu # alignItemsInRowsWithArray: = variadic_2_array; name:"alignItemsInRows",
                CCMenu # alignItemsInColumnsWithArray: = variadic_2_array; name:"alignItemsInColumns",
                CCLayer # setIsMouseEnabled: = name:"setMouseEnabled",
                CCLayer # isMouseEnabled = name:"getMouseEnabled",
                CCLayer # ccMouseUp: = callback; no_swizzle; name:"onMouseUp",
                CCLayer # ccMouseDown: = callback; no_swizzle; name:"onMouseDown",
                CCLayer # ccMouseDragged: = callback; no_swizzle; name:"onMouseDragged",
                CCLayerColor # layerWithColor: = name:"create",
                CCLayerGradient # initWithColor:fadingTo:alongVector: = name:"init"; merge:"initWithColor:fadingTo:",
                CCLayerGradient # layerWithColor:fadingTo:alongVector: = name:"create"; merge:"layerWithColor:fadingTo:",
#
# Struct properties
# options:
#   opaque              The structure will be treated as 'opaque' and can't not be inspected from JS.
#                       Opaque structures are much faster to generate than 'manual' or 'automatic' structures
#   manual:[func]       Manual conversion is provided for this structures. jsval_to_structname() and structname_to_jsval shall exists in your project
#                       If "func" is passed, it will call that conversion function
struct_properties = CGPoint = manual,
                    CGSize = manual,
                    CGRect = manual,
                    ccColor3B = manual,
                    ccColor4B = manual,
                    ccColor4F = manual,
                    ccGridSize = manual,

# BridgeSupport files
# add as many as you need. Usually you will only one.
bridge_support_file = cocos2d-mac.bridgesupport

# File that contains information that complements BridgeSupport (not present on BridgeSupport file)
complement_file = cocos2d-mac-complement.txt


#########################################################
#
#           cocos2d iOS
#
# Contains information for classes with specific iOS
# information like CCLayer (its subclasses should also
# be added here)
#########################################################
[cocos2d_ios]

# prefix that will be removed from the ObjC classes in order to generate the JS classes
# ex: If the class name is CCNode, then on JavaScript it will be Node
obj_class_prefix_to_remove = CC

# Classes to generate. Use '*' to generate all the parsed classes.
# Subclasses will be parsed as well.
# ex: If CCSprite is parsed, then CCNode and NSObject will be parsed as well
# It supports regular expressions to match class names.
# eg: all cocos2d actions ending in 'By': CC(.*)By
classes_to_parse = CCNode, CCLayer(.*), CCMenu, CCDirector(.*)

# Classes to ignore.
# It is a good idea to add classes that you don't want to have a proxy object. Usually internal classes,
# or classes that are already native on JavaScript should be added here.
# It supports regular expressions to match class names.
# eg: all NS classes: NS(.*)
classes_to_ignore = NS(.*)

# Class properties
# Options
#  manual               Means that the class is manually bound. No binding info will generated, but it can be used.
#  name:"newname"       New name of the class
class_properties =  NSObject = manual,
                UIEvent = manual,
                UITouch = manual,
                CCScene = manual,
                CCScheduler = manual,
                CCActionManager = manual,
                CCNode = manual,

# Whether or not to generate constructors from base classes for the current class.
# In JavaScript, the "constructors" or "static methods" are not "inherited".
# It is recommended to set it to "auto".
# Options:
#    False: Don't inherited
#    True: Inherit all class methods from all ancestors
#    Auto: Inherit only if it has no class constructors. Stop when the fist class constructor is added.
inherit_class_methods = Auto

# Files that are going to be imported by the autogenerated files.
# Useful to declare subclasses of an already bound project
# eg: manual bindings for NSObject
import_files =  js_bindings_cocos2d_classes.h

# The prefix will be removed from function name.
# eg: if the C function is "cpBodyAddShape", then the JS name will be "bodyWithAddShape"
## For cocos2d add "cc"
function_prefix_to_remove =

# Free functions to be parsed
functions_to_parse =
# Free functions not to parse
functions_to_ignore =

# Rules used for methods:
# options:
#   name:"js_name"         Rename methods.
#   ignore                 This method will be ignored.
#   callback               This method is a callback. It will be invoked from Objective-C
#   no_swizzle             It means that the callback function is an optional protocol and should not be "swizzled" because there is no implementation for it.
#   variadic_2_array       It means that all arguments are variadic, and an Array will be created with them
#
#  Regular expressions are supported in the Class name, but not in the Method name
#
method_properties =  CC(.*) # node = name:"create",
                CCDirector # sharedDirector = name:"getInstance",
                CCDirector # winSize = name:"getWinSize",
                CCMenu # menuWithArray: = variadic_2_array; name:"create",
                CCMenu # alignItemsInRowsWithArray: = variadic_2_array; name:"alignItemsInRows",
                CCMenu # alignItemsInColumnsWithArray: = variadic_2_array; name:"alignItemsInColumns",
                CCLayer # setIsTouchEnabled: = name:"setTouchEnabled",
                CCLayer # isTouchEnabled = name:"getTouchEnabled",
                CCLayer # ccTouchesBegan:withEvent: = callback; no_swizzle; name:"onTouchesBegan",
                CCLayer # ccTouchesCancelled:withEvent: = callback; no_swizzle; name:"onTouchesCancelled",
                CCLayer # ccTouchesEnded:withEvent: = callback; no_swizzle; name:"onTouchesEnded",
                CCLayer # ccTouchesMoved:withEvent: = callback; no_swizzle; name:"onTouchesMoved",
                CCLayerColor # layerWithColor: = name:"create",
                CCLayerGradient # initWithColor:fadingTo:alongVector: = name:"init"; merge:"initWithColor:fadingTo:",
                CCLayerGradient # layerWithColor:fadingTo:alongVector: = name:"create"; merge:"layerWithColor:fadingTo:",

#
# Struct properties
# options:
#   opaque              The structure will be treated as 'opaque' and can't not be inspected from JS.
#                       Opaque structures are much faster to generate than 'manual' or 'automatic' structures
#   manual:[func]       Manual conversion is provided for this structures. jsval_to_structname() and structname_to_jsval shall exists in your project
#                       If "func" is passed, it will call that conversion function
struct_properties = CGPoint = manual,
                    CGSize = manual,
                    CGRect = manual,
                    ccColor3B = manual,
                    ccColor4B = manual,
                    ccColor4F = manual,
                    ccGridSize = manual,

# BridgeSupport files
# add as many as you need. Usually you will only one.
bridge_support_file = cocos2d-ios.bridgesupport

# File that contains information that complements BridgeSupport (not present on BridgeSupport file)
complement_file = cocos2d-ios-complement.txt
